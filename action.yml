name: 'Automatic Version and Release Manager'
description: 'Automatically manage versions and create releases with changelog notes'
author: 'Your Name'

inputs:
  token:
    description: 'GitHub token for authentication'
    required: true
  draft:
    description: 'Create a draft release'
    required: false
    default: 'false'
  prerelease:
    description: 'Create a pre-release'
    required: false
    default: 'false'
  changelog_file:
    description: 'Path to changelog file'
    required: false
    default: 'CHANGELOG.md'
  tag:
    description: 'Specific tag to extract release notes for (optional)'
    required: false
    default: ''

outputs:
  new_version:
    description: 'The new version number'
  previous_version:
    description: 'The previous version number'
  bump:
    description: 'The type of bump performed (major, minor, patch, or none)'
  release_notes:
    description: 'The extracted release notes'

runs:
  using: 'composite'
  steps:
    - name: Set up Git
      shell: bash
      run: |
        git config user.name "${GITHUB_ACTOR}"
        git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"

    - name: Get previous version
      shell: bash
      run: |
        if [ -n "${{ inputs.tag }}" ]; then
          echo "PREVIOUS_VERSION=${{ inputs.tag }}" >> $GITHUB_ENV
          echo "previous_version=${{ inputs.tag }}" >> $GITHUB_OUTPUT
          echo "TAG_MODE=true" >> $GITHUB_ENV
        else
          PREVIOUS_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          PREVIOUS_VERSION=${PREVIOUS_VERSION#v}
          echo "PREVIOUS_VERSION=${PREVIOUS_VERSION}" >> $GITHUB_ENV
          echo "previous_version=${PREVIOUS_VERSION}" >> $GITHUB_OUTPUT
          echo "TAG_MODE=false" >> $GITHUB_ENV
        fi

    - name: Determine version bump
      if: env.TAG_MODE != 'true'
      shell: bash
      run: |
        PR_TITLE="${{ github.event.pull_request.title }}"
        if [[ $PR_TITLE == *"BREAKING CHANGE"* ]] || [[ $PR_TITLE == *"!"* ]]; then
          echo "BUMP=major" >> $GITHUB_ENV
          echo "bump=major" >> $GITHUB_OUTPUT
        elif [[ $PR_TITLE == *"feat"* ]]; then
          echo "BUMP=minor" >> $GITHUB_ENV
          echo "bump=minor" >> $GITHUB_OUTPUT
        elif [[ $PR_TITLE == *"fix"* ]] || [[ $PR_TITLE == *"docs"* ]] || [[ $PR_TITLE == *"chore"* ]] || [[ $PR_TITLE == *"refactor"* ]]; then
          echo "BUMP=patch" >> $GITHUB_ENV
          echo "bump=patch" >> $GITHUB_OUTPUT
        else
          echo "BUMP=none" >> $GITHUB_ENV
          echo "bump=none" >> $GITHUB_OUTPUT
        fi

    - name: Calculate new version
      if: env.TAG_MODE != 'true'
      shell: bash
      run: |
        if [ "$BUMP" != "none" ]; then
          IFS='.' read -r -a version_parts <<< "$PREVIOUS_VERSION"
          MAJOR="${version_parts[0]:-0}"
          MINOR="${version_parts[1]:-0}"
          PATCH="${version_parts[2]:-0}"
          
          case $BUMP in
            major)
              NEW_VERSION="$((MAJOR + 1)).0.0"
              ;;
            minor)
              NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
              ;;
            patch)
              NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
              ;;
          esac
          
          echo "NEW_VERSION=${NEW_VERSION}" >> $GITHUB_ENV
          echo "new_version=${NEW_VERSION}" >> $GITHUB_OUTPUT
        fi

    - name: Extract release notes
      shell: bash
      id: extract_notes
      run: |
        # Function to extract section between two patterns
        extract_section() {
          local start_pattern="$1"
          local file="$2"
          local section=""
          local in_section=false
          
          while IFS= read -r line; do
            if [[ "$line" =~ ^##[[:space:]]\[ && $in_section == true ]]; then
              break
            fi
            if [[ "$line" =~ ^##[[:space:]]\[$start_pattern ]]; then
              in_section=true
              section+="$line"$'\n'
              continue
            fi
            if [[ $in_section == true ]]; then
              section+="$line"$'\n'
            fi
          done < "$file"
          
          echo "$section"
        }
        
        VERSION_TO_EXTRACT="${NEW_VERSION:-${PREVIOUS_VERSION}}"
        
        # First try to extract unreleased section
        if [ "$BUMP" != "none" ]; then
          RELEASE_NOTES=$(extract_section "Unreleased" "${{ inputs.changelog_file }}")
        fi
        
        # If no unreleased section or we're in tag mode, try to extract specific version
        if [ -z "$RELEASE_NOTES" ] || [ "$TAG_MODE" = "true" ]; then
          RELEASE_NOTES=$(extract_section "$VERSION_TO_EXTRACT" "${{ inputs.changelog_file }}")
          # Try with 'v' prefix if not found
          if [ -z "$RELEASE_NOTES" ]; then
            RELEASE_NOTES=$(extract_section "v$VERSION_TO_EXTRACT" "${{ inputs.changelog_file }}")
          fi
        fi
        
        # Add PR information if available
        if [ -n "${{ github.event.pull_request.title }}" ]; then
          PR_INFO="### Pull Request\n"
          PR_INFO+="- Title: ${{ github.event.pull_request.title }}\n"
          if [ -n "${{ github.event.pull_request.body }}" ]; then
            PR_INFO+="- Description: ${{ github.event.pull_request.body }}\n"
          fi
          RELEASE_NOTES="$PR_INFO\n$RELEASE_NOTES"
        fi
        
        if [ -z "$RELEASE_NOTES" ]; then
          echo "No release notes found for version ${VERSION_TO_EXTRACT}"
          exit 1
        fi
        
        # Escape the release notes for GitHub Actions
        RELEASE_NOTES="${RELEASE_NOTES//'%'/'%25'}"
        RELEASE_NOTES="${RELEASE_NOTES//$'\n'/'%0A'}"
        RELEASE_NOTES="${RELEASE_NOTES//$'\r'/'%0D'}"
        
        echo "release_notes=${RELEASE_NOTES}" >> $GITHUB_OUTPUT
        echo "RELEASE_NOTES=${RELEASE_NOTES}" >> $GITHUB_ENV

    - name: Update CHANGELOG.md
      if: env.TAG_MODE != 'true' && env.BUMP != 'none' && env.NEW_VERSION != ''
      shell: bash
      run: |
        current_date=$(date +%Y-%m-%d)
        
        # Create temporary changelog
        {
          echo "# Changelog"
          echo ""
          echo "## [Unreleased]"
          echo ""
          echo "### Added"
          echo "- No unreleased changes"
          echo ""
          echo "## [${NEW_VERSION}] - ${current_date}"
          
          # Extract and insert current unreleased content
          awk '/^## \[Unreleased\]/{p=1;next} /^## \[/{p=0} p' "${{ inputs.changelog_file }}" | \
          grep -v "^### Added" | grep -v "^- No unreleased changes" | grep -v "^$"
          
          # Add rest of the changelog
          sed -n '/^## \[[0-9]/,$p' "${{ inputs.changelog_file }}"
        } > temp_changelog
        
        mv temp_changelog "${{ inputs.changelog_file }}"
        
        git add "${{ inputs.changelog_file }}"
        git commit -m "docs: update changelog for version ${NEW_VERSION}"
        git push

    - name: Create and push tag
      if: env.TAG_MODE != 'true' && env.BUMP != 'none' && env.NEW_VERSION != ''
      shell: bash
      run: |
        git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
        git push origin "v$NEW_VERSION"

    - name: Create Release
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        VERSION_TO_RELEASE="${NEW_VERSION:-${PREVIOUS_VERSION}}"
        
        # Create JSON payload for the release
        jq -n \
          --arg tag_name "v$VERSION_TO_RELEASE" \
          --arg name "Release v$VERSION_TO_RELEASE" \
          --arg body "$RELEASE_NOTES" \
          --argjson draft ${{ inputs.draft }} \
          --argjson prerelease ${{ inputs.prerelease }} \
          '{
            tag_name: $tag_name,
            name: $name,
            body: $body,
            draft: $draft,
            prerelease: $prerelease
          }' > release_payload.json
        
        # Create release using GitHub API
        curl \
          -X POST \
          -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/$GITHUB_REPOSITORY/releases" \
          -d @release_payload.json
