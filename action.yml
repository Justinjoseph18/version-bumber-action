name: 'Automatic Version and Release Manager'
description: 'Automatically manage versions and create releases with changelog notes'
author: 'Justin Joseph'

inputs:
  token:
    description: 'GitHub token for authentication'
    required: true
  draft:
    description: 'Create a draft release'
    required: false
    default: 'false'
  prerelease:
    description: 'Create a pre-release'
    required: false
    default: 'false'
  changelog_file:
    description: 'Path to changelog file'
    required: false
    default: 'CHANGELOG.md'
  tag:
    description: 'Specific tag to extract release notes for (optional)'
    required: false
    default: ''

outputs:
  new_version:
    description: 'The new version number'
  previous_version:
    description: 'The previous version number'
  bump:
    description: 'The type of bump performed (major, minor, patch, or none)'
  release_notes:
    description: 'The extracted release notes'

runs:
  using: 'composite'
  steps:
    - name: Set up Git
      shell: bash
      run: |
        git config user.name "${GITHUB_ACTOR}"
        git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"

    - name: Get previous version
      shell: bash
      run: |
        if [ -n "${{ inputs.tag }}" ]; then
          echo "PREVIOUS_VERSION=${{ inputs.tag }}" >> $GITHUB_ENV
          echo "previous_version=${{ inputs.tag }}" >> $GITHUB_OUTPUT
          echo "TAG_MODE=true" >> $GITHUB_ENV
        else
          PREVIOUS_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          PREVIOUS_VERSION=${PREVIOUS_VERSION#v}
          echo "PREVIOUS_VERSION=${PREVIOUS_VERSION}" >> $GITHUB_ENV
          echo "previous_version=${PREVIOUS_VERSION}" >> $GITHUB_OUTPUT
          echo "TAG_MODE=false" >> $GITHUB_ENV
        fi

    - name: Determine version bump
      if: env.TAG_MODE != 'true'
      shell: bash
      run: |
        PR_TITLE="${{ github.event.pull_request.title }}"
        if [[ $PR_TITLE == *"BREAKING CHANGE"* ]] || [[ $PR_TITLE == *"!"* ]]; then
          echo "BUMP=major" >> $GITHUB_ENV
          echo "bump=major" >> $GITHUB_OUTPUT
        elif [[ $PR_TITLE == *"feat"* ]]; then
          echo "BUMP=minor" >> $GITHUB_ENV
          echo "bump=minor" >> $GITHUB_OUTPUT
        elif [[ $PR_TITLE == *"fix"* ]] || [[ $PR_TITLE == *"docs"* ]] || [[ $PR_TITLE == *"chore"* ]] || [[ $PR_TITLE == *"refactor"* ]]; then
          echo "BUMP=patch" >> $GITHUB_ENV
          echo "bump=patch" >> $GITHUB_OUTPUT
        else
          echo "BUMP=none" >> $GITHUB_ENV
          echo "bump=none" >> $GITHUB_OUTPUT
        fi

    - name: Calculate new version
      if: env.TAG_MODE != 'true'
      shell: bash
      run: |
        if [ "$BUMP" != "none" ]; then
          IFS='.' read -r -a version_parts <<< "$PREVIOUS_VERSION"
          MAJOR="${version_parts[0]:-0}"
          MINOR="${version_parts[1]:-0}"
          PATCH="${version_parts[2]:-0}"
          
          case $BUMP in
            major)
              NEW_VERSION="$((MAJOR + 1)).0.0"
              ;;
            minor)
              NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
              ;;
            patch)
              NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
              ;;
          esac
          
          echo "NEW_VERSION=${NEW_VERSION}" >> $GITHUB_ENV
          echo "new_version=${NEW_VERSION}" >> $GITHUB_OUTPUT
        fi

    - name: Extract release notes
      shell: bash
      id: extract_notes
      run: |
        VERSION_TO_EXTRACT="${NEW_VERSION:-${PREVIOUS_VERSION}}"
        
        # First, get the PR title and body
        PR_TITLE="${{ github.event.pull_request.title }}"
        PR_BODY="${{ github.event.pull_request.body }}"
        
        # Extract Unreleased section from changelog
        UNRELEASED_CONTENT=$(awk '/^## \[Unreleased\]/{p=1;next} /^## \[/{p=0} p' "${{ inputs.changelog_file }}")
        
        # Combine PR information with Unreleased content
        RELEASE_NOTES="## Changes\n\n"
        RELEASE_NOTES+="PR: ${PR_TITLE}\n\n"
        
        if [ ! -z "$PR_BODY" ]; then
          RELEASE_NOTES+="Description:\n${PR_BODY}\n\n"
        fi
        
        if [ ! -z "$UNRELEASED_CONTENT" ]; then
          RELEASE_NOTES+="Changelog:\n${UNRELEASED_CONTENT}\n"
        fi
        
        # Escape the release notes for GitHub Actions
        RELEASE_NOTES="${RELEASE_NOTES//'%'/'%25'}"
        RELEASE_NOTES="${RELEASE_NOTES//$'\n'/'%0A'}"
        RELEASE_NOTES="${RELEASE_NOTES//$'\r'/'%0D'}"
        
        echo "release_notes=${RELEASE_NOTES}" >> $GITHUB_OUTPUT
        echo "RELEASE_NOTES=${RELEASE_NOTES}" >> $GITHUB_ENV

    - name: Update CHANGELOG.md
      if: env.TAG_MODE != 'true' && env.BUMP != 'none' && env.NEW_VERSION != ''
      shell: bash
      run: |
        PR_TITLE="${{ github.event.pull_request.title }}"
        current_date=$(date +%Y-%m-%d)
        
        # Create temporary file
        touch temp_changelog
        
        # Read changelog line by line
        in_unreleased=false
        while IFS= read -r line || [ -n "$line" ]; do
          if [[ $line == "## [Unreleased]"* ]]; then
            # Write Unreleased section
            echo "$line" >> temp_changelog
            echo "" >> temp_changelog
            echo "### Added" >> temp_changelog
            echo "- No unreleased changes" >> temp_changelog
            echo "" >> temp_changelog
            
            # Add new version section with content from Unreleased
            echo "## [${NEW_VERSION}] - ${current_date}" >> temp_changelog
            echo "" >> temp_changelog
            echo "### Changes" >> temp_changelog
            echo "- ${PR_TITLE}" >> temp_changelog
            echo "" >> temp_changelog
            
            # Copy existing Unreleased content
            while IFS= read -r content_line; do
              if [[ $content_line == "## ["* ]]; then
                break
              fi
              if [[ $content_line != "### Added"* && $content_line != "- No unreleased changes"* ]]; then
                echo "$content_line" >> temp_changelog
              fi
            done < <(tail -n +2 "${{ inputs.changelog_file }")
            in_unreleased=true
          elif ! $in_unreleased; then
            echo "$line" >> temp_changelog
          fi
        done < "${{ inputs.changelog_file }}"
        
        mv temp_changelog "${{ inputs.changelog_file }}"
        
        git add "${{ inputs.changelog_file }}"
        git commit -m "docs: update changelog for version ${NEW_VERSION}"
        git push

    - name: Create and push tag
      if: env.TAG_MODE != 'true' && env.BUMP != 'none' && env.NEW_VERSION != ''
      shell: bash
      run: |
        git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
        git push origin "v$NEW_VERSION"

    - name: Create Release
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        VERSION_TO_RELEASE="${NEW_VERSION:-${PREVIOUS_VERSION}}"
        
        # Create JSON payload for the release
        jq -n \
          --arg tag_name "v$VERSION_TO_RELEASE" \
          --arg name "Release v$VERSION_TO_RELEASE" \
          --arg body "$RELEASE_NOTES" \
          --argjson draft ${{ inputs.draft }} \
          --argjson prerelease ${{ inputs.prerelease }} \
          '{
            tag_name: $tag_name,
            name: $name,
            body: $body,
            draft: $draft,
            prerelease: $prerelease
          }' > release_payload.json
        
        # Create release using GitHub API
        curl \
          -X POST \
          -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/$GITHUB_REPOSITORY/releases" \
          -d @release_payload.json
