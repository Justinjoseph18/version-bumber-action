name: 'Automatic Version Bumper'
description: 'Automatically bump version and create release with changelog notes'
author: 'Your Name'

inputs:
  token:
    description: 'GitHub token for authentication'
    required: true
  draft:
    description: 'Create a draft release'
    required: false
    default: 'false'
  prerelease:
    description: 'Create a pre-release'
    required: false
    default: 'false'
  changelog_file:
    description: 'Path to changelog file'
    required: false
    default: 'CHANGELOG.md'

outputs:
  new_version:
    description: 'The new version number'
  previous_version:
    description: 'The previous version number'
  bump:
    description: 'The type of bump performed (major, minor, patch, or none)'
  release_notes:
    description: 'The extracted release notes'

runs:
  using: 'composite'
  steps:
    - name: Set up Git
      shell: bash
      run: |
        git config user.name "${GITHUB_ACTOR}"
        git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"

    - name: Get previous version
      shell: bash
      run: |
        PREVIOUS_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        PREVIOUS_VERSION=${PREVIOUS_VERSION#v}
        echo "PREVIOUS_VERSION=${PREVIOUS_VERSION}" >> $GITHUB_ENV
        echo "previous_version=${PREVIOUS_VERSION}" >> $GITHUB_OUTPUT

    - name: Determine version bump
      shell: bash
      run: |
        PR_TITLE="${{ github.event.pull_request.title }}"
        if [[ $PR_TITLE == *"BREAKING CHANGE"* ]]; then
          echo "BUMP=major" >> $GITHUB_ENV
          echo "bump=major" >> $GITHUB_OUTPUT
        elif [[ $PR_TITLE == *"feat"* ]]; then
          echo "BUMP=minor" >> $GITHUB_ENV
          echo "bump=minor" >> $GITHUB_OUTPUT
        elif [[ $PR_TITLE == *"fix"* ]]; then
          echo "BUMP=patch" >> $GITHUB_ENV
          echo "bump=patch" >> $GITHUB_OUTPUT
        else
          echo "BUMP=none" >> $GITHUB_ENV
          echo "bump=none" >> $GITHUB_OUTPUT
        fi

    - name: Calculate new version
      shell: bash
      run: |
        if [ "$BUMP" != "none" ]; then
          IFS='.' read -r -a version_parts <<< "$PREVIOUS_VERSION"
          MAJOR="${version_parts[0]}"
          MINOR="${version_parts[1]}"
          PATCH="${version_parts[2]}"
          
          case $BUMP in
            major)
              NEW_VERSION="$((MAJOR + 1)).0.0"
              ;;
            minor)
              NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
              ;;
            patch)
              NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
              ;;
          esac
          
          echo "NEW_VERSION=${NEW_VERSION}" >> $GITHUB_ENV
          echo "new_version=${NEW_VERSION}" >> $GITHUB_OUTPUT
        fi

    - name: Update CHANGELOG.md
      if: env.BUMP != 'none' && env.NEW_VERSION != ''
      shell: bash
      run: |
        # Create a temporary file
        touch temp_changelog
        current_date=$(date +%Y-%m-%d)
        
        # Read the original CHANGELOG.md line by line
        while IFS= read -r line || [ -n "$line" ]; do
          if [[ $line == "## [Unreleased]"* ]]; then
            # Write the Unreleased header
            echo "$line" >> temp_changelog
            # Add a new empty unreleased section
            echo "" >> temp_changelog
            echo "### Added" >> temp_changelog
            echo "- No unreleased changes" >> temp_changelog
            echo "" >> temp_changelog
            # Add the new version header
            echo "## [${NEW_VERSION}] - ${current_date}" >> temp_changelog
          else
            echo "$line" >> temp_changelog
          fi
        done < "${{ inputs.changelog_file }}"
        
        # Replace the original file
        mv temp_changelog "${{ inputs.changelog_file }}"
        
        # Stage the changes
        git add "${{ inputs.changelog_file }}"
        git commit -m "docs: update changelog for version ${NEW_VERSION}"
        git push

    - name: Extract release notes
      if: env.BUMP != 'none' && env.NEW_VERSION != ''
      shell: bash
      id: extract_notes
      run: |
        # Extract everything between the new version header and the next version header
        RELEASE_NOTES=$(awk "/## \[${NEW_VERSION}\]/{p=1;print;next} /## \[/{p=0} p" "${{ inputs.changelog_file }}")
        
        # Escape the release notes for GitHub Actions
        RELEASE_NOTES="${RELEASE_NOTES//'%'/'%25'}"
        RELEASE_NOTES="${RELEASE_NOTES//$'\n'/'%0A'}"
        RELEASE_NOTES="${RELEASE_NOTES//$'\r'/'%0D'}"
        
        echo "release_notes=${RELEASE_NOTES}" >> $GITHUB_OUTPUT
        echo "RELEASE_NOTES=${RELEASE_NOTES}" >> $GITHUB_ENV

    - name: Create and push tag
      if: env.BUMP != 'none' && env.NEW_VERSION != ''
      shell: bash
      run: |
        git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
        git push origin "v$NEW_VERSION"

    - name: Create Release
      if: env.BUMP != 'none' && env.NEW_VERSION != ''
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        # Create JSON payload for the release
        jq -n \
          --arg tag_name "v$NEW_VERSION" \
          --arg name "Release v$NEW_VERSION" \
          --arg body "$RELEASE_NOTES" \
          --argjson draft ${{ inputs.draft }} \
          --argjson prerelease ${{ inputs.prerelease }} \
          '{
            tag_name: $tag_name,
            name: $name,
            body: $body,
            draft: $draft,
            prerelease: $prerelease
          }' > release_payload.json
        
        # Create release using GitHub API
        curl \
          -X POST \
          -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/$GITHUB_REPOSITORY/releases" \
          -d @release_payload.json
